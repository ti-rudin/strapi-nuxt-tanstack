#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const STRAPI_URL = process.env.NUXT_PUBLIC_STRAPI_URL || 'http://localhost:1337';
const TYPES_DIR = path.join(__dirname, '../shared-types');

// Ensure types directory exists
if (!fs.existsSync(TYPES_DIR)) {
  fs.mkdirSync(TYPES_DIR, { recursive: true });
}

/**
 * Fetch content types from Strapi
 */
async function fetchContentTypes() {
  try {
    const response = await fetch(`${STRAPI_URL}/api`);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch from Strapi: ${response.statusText}`);
    }
    
    const apiData = await response.json();
    return apiData;
  } catch (error) {
    console.error('Error fetching content types:', error.message);
    return null;
  }
}

/**
 * Generate TypeScript types from Strapi content types
 */
function generateTypes(apiData) {
  let typeDefinitions = `// Auto-generated by synctypes script
// DO NOT EDIT THIS FILE MANUALLY
// Run 'npm run synctypes' to regenerate

export interface StrapiMediaAttributes {
  name: string;
  alternativeText?: string | null;
  caption?: string | null;
  width?: number;
  height?: number;
  formats?: any;
  hash: string;
  ext?: string;
  mime: string;
  size: number;
  url: string;
  previewUrl?: string | null;
  provider: string;
  provider_metadata?: any | null;
  createdAt: string;
  updatedAt: string;
}

export interface StrapiMediaData {
  id: number;
  attributes: StrapiMediaAttributes;
}

export interface StrapiArticleAttributes {
  title: string;
  content: string;
  publishedAt: string;
  createdAt: string;
  updatedAt: string;
  cover?: StrapiMediaData | null;
  [key: string]: any;
}

export interface StrapiArticle {
  id: number;
  attributes: StrapiArticleAttributes;
}

export interface StrapiCollectionData<T> {
  data: T[];
  meta?: {
    pagination?: {
      page: number;
      pageSize: number;
      pageCount: number;
      total: number;
    };
  };
}

export interface StrapiSingleData<T> {
  data: T | null;
  meta?: Record<string, any>;
}

`;

  // Try to generate types for each content type found
  if (apiData && apiData.data && typeof apiData.data === 'object') {
    const contentTypes = Object.keys(apiData.data);
    if (contentTypes.length > 0) {
      typeDefinitions += '// Content types found in Strapi:\n';
      typeDefinitions += '// ' + contentTypes.join(', ') + '\n\n';
    }
  }

  return typeDefinitions;
}

/**
 * Main function
 */
async function main() {
  console.log('üîÑ Syncing types from Strapi...');
  console.log(`üìç Strapi URL: ${STRAPI_URL}`);

  const apiData = await fetchContentTypes();
  
  console.log('üí° Creating type definitions...');
  
  // Always generate basic types
  const typeDefinitions = generateTypes(apiData);
  
  if (typeDefinitions) {
    const outputPath = path.join(TYPES_DIR, 'index.ts');
    fs.writeFileSync(outputPath, typeDefinitions);
    console.log(`‚úÖ Types written to: ${outputPath}`);
  } else {
    console.log('‚ö†Ô∏è  No types to generate');
  }

  console.log('‚ú® Done!');
}

// Run the script
main().catch(console.error);

